

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="[[CharyGao]]">
  <meta name="keywords" content="java,博客,vue,spring,mysql,docker,linux">
  
    <meta name="description" content="在使用 Spring Boot 时，开发者常常会感到惊讶：为什么这么少的配置却能实现如此丰富的功能？为何启动一个 Spring Boot 应用可以变得如此简单便捷？在这个看似平凡的启动过程中，其实隐藏着一套精妙的自动化机制和源码逻辑。本文将带你深入探索 Spring Boot 的启动流程，逐步揭开自">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring Boot 启动过程与自动配置详解：从源码到实现">
<meta property="og:url" content="https://yhao521.github.io/2025/10/08/%E6%91%98%E5%BD%95/Spring%20Boot%20%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%EF%BC%9A%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="匆匆过客的博客">
<meta property="og:description" content="在使用 Spring Boot 时，开发者常常会感到惊讶：为什么这么少的配置却能实现如此丰富的功能？为何启动一个 Spring Boot 应用可以变得如此简单便捷？在这个看似平凡的启动过程中，其实隐藏着一套精妙的自动化机制和源码逻辑。本文将带你深入探索 Spring Boot 的启动流程，逐步揭开自">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-08T12:30:51.492Z">
<meta property="article:modified_time" content="2025-10-08T12:30:59.221Z">
<meta property="article:author" content="yhao521">
<meta property="article:tag" content="clippings">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Spring Boot 启动过程与自动配置详解：从源码到实现 - 匆匆过客的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"yhao521.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null},"woyaola":null,"cnzz":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>匆匆过客的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Spring Boot 启动过程与自动配置详解：从源码到实现"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-08 20:30" pubdate>
          2025年10月8日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.7k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          48 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Spring Boot 启动过程与自动配置详解：从源码到实现</h1>
            
            
              <div class="markdown-body">
                
                <p>在使用 Spring Boot 时，开发者常常会感到惊讶：为什么这么少的配置却能实现如此丰富的功能？为何启动一个 Spring Boot 应用可以变得如此简单便捷？在这个看似平凡的启动过程中，其实隐藏着一套精妙的自动化机制和源码逻辑。本文将带你深入探索 Spring Boot 的启动流程，逐步揭开自动配置的幕后奥秘。通过了解这些底层原理，你将发现，原来每一次应用的无缝启动都是精心设计的结果，让你对 Spring Boot 有更深刻的理解和掌控力！</p>
<h2 id="一、整体概述"><a href="#一、整体概述" class="headerlink" title="一、整体概述"></a>一、整体概述</h2><h3 id="（一）基本整体初步分析"><a href="#（一）基本整体初步分析" class="headerlink" title="（一）基本整体初步分析"></a>（一）基本整体初步分析</h3><p><strong>Spring Boot 是一个用于构建独立的、生产级的 Spring 应用程序的框架，它提供了自动化的配置和约定优于配置的原则。</strong> 在理解 Spring Boot 的启动配置原理之前，我们需要了解几个关键概念。</p>
<p><strong>首先，Spring Boot 使用了基于约定的自动配置机制</strong> 。它通过在 classpath 下查找特定的配置文件和类，根据应用程序所使用的依赖自动配置 Spring 应用程序的各种组件。这样可以大大简化开发者的工作，减少了手动配置的需求。</p>
<p><strong>其次，Spring Boot 使用了条件化配置（Conditional Configuration）的机制。</strong> 这意味着配置的应用取决于一组条件是否满足。条件可以基于多种因素，如 classpath 中存在特定的类、特定的 bean 是否存在等等。通过条件化配置，Spring Boot 可以根据不同的环境和需求进行动态的配置。</p>
<p>Spring Boot 的启动配置原理可以概括如下：</p>
<ol>
<li>在启动过程中，Spring Boot 会加载并解析应用程序的配置文件，其中包括 application.properties 或 application.yml 文件等。这些文件中可以定义各种属性和配置信息，如数据库连接、日志级别等。</li>
<li>Spring Boot 会自动扫描 classpath 下的特定包，寻找带有特定注解的类，如 @SpringBootApplication。这个注解标识了一个 Spring Boot 应用程序的入口点。</li>
<li>根据配置文件中的属性和条件化配置的机制，Spring Boot 自动配置应用程序的各种组件，包括数据库连接池、消息队列、Web 服务器等。如果需要进行自定义配置，可以使用专门的注解或编写自定义的配置类。</li>
<li>在应用程序启动时，Spring Boot 会初始化 Spring 容器，并根据配置进行相应的初始化工作。这包括创建和管理 bean、处理依赖注入等。</li>
</ol>
<p>总的来说，Spring Boot 的启动配置原理是基于自动化的约定和条件化配置机制。它通过读取配置文件、扫描注解、自动配置组件等步骤，简化了应用程序的配置过程，并提供了灵活性和易用性。</p>
<h3 id="（二）从启动来看整体过程图分析"><a href="#（二）从启动来看整体过程图分析" class="headerlink" title="（二）从启动来看整体过程图分析"></a>（二）从启动来看整体过程图分析</h3><p>每个 SpringBoot 程序都有一个主入口main方法，main里面调用SpringApplication.run()启动整个SpringBoot程序，该方法所在类需要使用@SpringBootApplication注解，例如如下</p>
<ol>
<li>package org.zyf.javabasic;</li>
<li>import org.springframework.boot.SpringApplication;</li>
<li>import org.springframework.boot.autoconfigure.SpringBootApplication;</li>
<li>import org.springframework.context.ApplicationContext;</li>
<li>import org.springframework.context.annotation.ComponentScan;</li>
<li>import org.springframework.context.annotation.EnableAspectJAutoProxy;</li>
<li>import springfox.documentation.swagger2.annotations.EnableSwagger2;</li>
<li>&#x2F;**</li>
<li>* 描述：启动入口类</li>
<li>*</li>
<li>* @author yanfengzhang</li>
<li>* @date 2019-12-19 18:11</li>
<li>*&#x2F;</li>
<li>@SpringBootApplication</li>
<li>@ComponentScan(basePackages &#x3D; {“org.zyf.javabasic”})</li>
<li>@EnableAspectJAutoProxy(proxyTargetClass &#x3D; true, exposeProxy &#x3D; true)</li>
<li>@EnableSwagger2</li>
<li>public class ZYFApplication {</li>
<li>public static void main (String[] args) {</li>
<li>ApplicationContext context = SpringApplication.run(ZYFApplication.class, args);</li>
<li>}</li>
</ol>
<p>其中对@SpringBootApplication进行展开分析：</p>
<ol>
<li>&#x2F;&#x2F;</li>
<li>&#x2F;&#x2F; Source code recreated from a.class file by IntelliJ IDEA</li>
<li>&#x2F;&#x2F; (powered by FernFlower decompiler)</li>
<li>&#x2F;&#x2F;</li>
<li>package org.springframework.boot.autoconfigure;</li>
<li>import java.lang.annotation.Documented;</li>
<li>import java.lang.annotation.ElementType;</li>
<li>import java.lang.annotation.Inherited;</li>
<li>import java.lang.annotation.Retention;</li>
<li>import java.lang.annotation.RetentionPolicy;</li>
<li>import java.lang.annotation.Target;</li>
<li>import org.springframework.boot.SpringBootConfiguration;</li>
<li>import org.springframework.boot.context.TypeExcludeFilter;</li>
<li>import org.springframework.context.annotation.ComponentScan;</li>
<li>import org.springframework.context.annotation.FilterType;</li>
<li>import org.springframework.context.annotation.ComponentScan.Filter;</li>
<li>import org.springframework.core.annotation.AliasFor;</li>
<li>@Target({ElementType.TYPE})</li>
<li>@Retention(RetentionPolicy.RUNTIME)</li>
<li>@Documented</li>
<li>@Inherited</li>
<li>@SpringBootConfiguration</li>
<li>@EnableAutoConfiguration</li>
<li>@ComponentScan(</li>
<li>excludeFilters &#x3D; {@Filter(</li>
<li>type &#x3D; FilterType.CUSTOM,</li>
<li>classes &#x3D; {TypeExcludeFilter.class}</li>
<li>), @Filter(</li>
<li>type &#x3D; FilterType.CUSTOM,</li>
<li>classes &#x3D; {AutoConfigurationExcludeFilter.class}</li>
<li>)}</li>
<li>)</li>
<li>public @interface SpringBootApplication {</li>
<li>@AliasFor(</li>
<li>annotation &#x3D; EnableAutoConfiguration.class</li>
<li>)</li>
<li>Class&lt;?&gt;[] exclude() default {};</li>
<li>@AliasFor(</li>
<li>annotation &#x3D; EnableAutoConfiguration.class</li>
<li>)</li>
<li>String[] excludeName() default {};</li>
<li>@AliasFor(</li>
<li>annotation &#x3D; ComponentScan.class,</li>
<li>attribute &#x3D; “basePackages”</li>
<li>)</li>
<li>String[] scanBasePackages() default {};</li>
<li>@AliasFor(</li>
<li>annotation &#x3D; ComponentScan.class,</li>
<li>attribute &#x3D; “basePackageClasses”</li>
<li>)</li>
<li>Class&lt;?&gt;[] scanBasePackageClasses() default {};</li>
<li>}</li>
</ol>
<p>@SpringBootApplication包括三个注解，功能如下：</p>
<ul>
<li>@SpringBootConfiguration(内部为@Configuration)：被标注的类等于在spring的XML配置文件中(applicationContext.xml)，装配所有bean事务，提供了一个spring的上下文环境</li>
<li>@ComponentScan：组件扫描，可自动发现和装配Bean（比如@Component和@Configuration），默认扫描SpringApplication的run方法里类所在的包路径下所有文件</li>
<li>@EnableAutoConfiguration：激活SpringBoot自动装配的特性</li>
</ul>
<p>现在对主入口main方法进行展开来给出整体的流程图分析</p>
<p>![[_resources&#x2F;06eb8019ab413a30098ac7fa5930a80b_MD5.png]]</p>
<h2 id="二、SpringApplication构造过程分析"><a href="#二、SpringApplication构造过程分析" class="headerlink" title="二、SpringApplication构造过程分析"></a>二、SpringApplication构造过程分析</h2><p>进入main里面的run方法，创建了一个SpringApplication实例，配置一些基本的环境变量、资源、构造器、监听器，进入这个SpringApplication有参构造函数</p>
<ol>
<li>public SpringApplication (ResourceLoader resourceLoader, Class&lt;?&gt;… primarySources) {</li>
<li>this.sources &#x3D; new LinkedHashSet ();</li>
<li>this.logStartupInfo &#x3D; true;</li>
<li>this.addCommandLineProperties &#x3D; true;</li>
<li>this.addConversionService &#x3D; true;</li>
<li>this.headless &#x3D; true;</li>
<li>this.additionalProfiles &#x3D; new HashSet ();</li>
<li>this.isCustomEnvironment &#x3D; false;</li>
<li>this.resourceLoader &#x3D; resourceLoader;</li>
<li>Assert.notNull(primarySources, “PrimarySources must not be null”);</li>
<li>this.primarySources &#x3D; new LinkedHashSet (Arrays.asList(primarySources));</li>
<li>this.webApplicationType &#x3D; WebApplicationType.deduceFromClasspath();</li>
<li>this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));</li>
<li>this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));</li>
<li>this.mainApplicationClass &#x3D; this.deduceMainApplicationClass();</li>
<li>}</li>
</ol>
<p>注意：在该构造方法内，做的工作就是把相关的类（主要是initializer和listener）加载进容器中，并没有执行</p>
<h3 id="（一）验证主配置类不为空并且保存主类"><a href="#（一）验证主配置类不为空并且保存主类" class="headerlink" title="（一）验证主配置类不为空并且保存主类"></a>（一）验证主配置类不为空并且保存主类</h3><p>![[_resources&#x2F;004fbc18099455787d41a059eec7ef76_MD5.png]]</p>
<h3 id="（二）推断项目的类型"><a href="#（二）推断项目的类型" class="headerlink" title="（二）推断项目的类型"></a>（二）推断项目的类型</h3><p>![[_resources&#x2F;9fb222d4ee50bb3114e0f2d1b96d542c_MD5.png]]</p>
<p>进入对应方法分析如下：</p>
<p>![[_resources&#x2F;067a2be06b9bf37fcddde27e3ce649e9_MD5.png]]</p>
<p>推断项目的类型可能为reactive、none、servlet三种类型，默认为servlet类型。其使用类加载器判断类型的逻辑如下</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>判断情况</th>
</tr>
</thead>
<tbody><tr>
<td>reactive</td>
<td>存在Spring WebFlux的DispatcherHandler存在，但是Spring MVC的DispatcherServlet不存在</td>
</tr>
<tr>
<td>none</td>
<td>二者都不存在</td>
</tr>
<tr>
<td>servlet</td>
<td>剩余所有情况</td>
</tr>
</tbody></table>
<h3 id="（三）初始化initializers"><a href="#（三）初始化initializers" class="headerlink" title="（三）初始化initializers"></a>（三）初始化initializers</h3><p>![[_resources&#x2F;c310d45857149989e0e7c7616aac0677_MD5.png]]</p>
<p>先进入ApplicationContextInitializer接口，这个接口只有一个方法initialize</p>
<ol>
<li>package org.springframework.context;</li>
<li>public interface ApplicationContextInitializer <C extends ConfigurableApplicationContext > {</li>
<li>void initialize (C var1);</li>
<li>}</li>
</ol>
<p>查看实现了该这个接口的类进行分析</p>
<p>![[_resources&#x2F;2ab45985396f8b62851789ca2c7fc6fc_MD5.png]]</p>
<p>以SharedMetadataReaderFactoryContextInitializer实现类为例，跳转对应jar包，可以看到里面 spring.factories就在key为ApplicationContextInitializer中指定了对应的实现类，例如：</p>
<p>![[_resources&#x2F;c56e8767e4a993ad89bc75b29e04efd6_MD5.png]]</p>
<p>进入SharedMetadataReaderFactoryContextInitializer，其实现了ApplicationContextInitializer接口，并实现了里面的initialize方法</p>
<p>![[_resources&#x2F;ceba5c424857951690c38ff8b63829ee_MD5.png]]</p>
<p>现在回到一开始再来看getSpringFactoriesInstance()方法，其核心为loadFactoryNames()方法</p>
<p>![[_resources&#x2F;3fbbea9d8985a40f686f38bcaac1977a_MD5.png]]</p>
<p>进入loadFactoryNames()方法，可以看到ApplicationContextInitializer的相关获取内容直接就是从文件“META-INF&#x2F;spring.factories”中获取保存的</p>
<p>![[_resources&#x2F;995806abb153b323664ebad98ba725d8_MD5.png]]</p>
<h3 id="（四）加载相关的listeners"><a href="#（四）加载相关的listeners" class="headerlink" title="（四）加载相关的listeners"></a>（四）加载相关的listeners</h3><p>![[_resources&#x2F;d95a5ab1d225eb7d7516eeabd06f3345_MD5.png]]</p>
<p>先进入ApplicationListener接口，这个接口只有一个方法onApplicationEvent</p>
<ol>
<li>package org.springframework.context;</li>
<li>import java.util.EventListener;</li>
<li>@FunctionalInterface</li>
<li>public interface ApplicationListener <E extends ApplicationEvent > extends EventListener {</li>
<li>void onApplicationEvent (E var1);</li>
<li>}</li>
</ol>
<p>查看实现了该这个接口的类进行分析</p>
<p>![[_resources&#x2F;f4cadcc0314119f293e315497a5d0b67_MD5.png]]</p>
<p>以BackgroundPreinitializer实现类为例，跳转对应jar包，可以看到里面 spring.factories就在key为ApplicationListener中指定了对应的实现类：</p>
<p>![[_resources&#x2F;7eca3c662e73c2aa021d044af40e10f8_MD5.png]]</p>
<p>进入BackgroundPreinitializer，其实现了ApplicationListener，并实现了里面的onApplicationEvent</p>
<p>方法如下：</p>
<p>![[_resources&#x2F;e9393e007e5187f76c102510bdf3dcde_MD5.png]]</p>
<p>现在回到一开始再来看getSpringFactoriesInstance()方法，其处理流程和上面的一样，即依然是从类路径下找到META-INF&#x2F;spring.factories配置的所有ApplicationListener</p>
<h3 id="（五）决定ApplicationClass主程序"><a href="#（五）决定ApplicationClass主程序" class="headerlink" title="（五）决定ApplicationClass主程序"></a>（五）决定ApplicationClass主程序</h3><p>![[_resources&#x2F;486a2bcc7816991846621f16fad9df39_MD5.png]]</p>
<p>进入deduceMainApplicationClass方法</p>
<p>![[_resources&#x2F;8122997823fc6374eae3c2ff609e1f01_MD5.png]]</p>
<h2 id="三、SpringApplication启动过程分析"><a href="#三、SpringApplication启动过程分析" class="headerlink" title="三、SpringApplication启动过程分析"></a>三、SpringApplication启动过程分析</h2><p>![[_resources&#x2F;1c84817d472e7292b8c2f7396459f128_MD5.png]]</p>
<p>SpringBoot启动方案，包括启动流程的监听模块、加载配置环境模块、及核心的创建上下文环境模块以及后续的收尾回调等内容</p>
<h3 id="（一）监控器监听容器启动并进行图形化页面处理"><a href="#（一）监控器监听容器启动并进行图形化页面处理" class="headerlink" title="（一）监控器监听容器启动并进行图形化页面处理"></a>（一）监控器监听容器启动并进行图形化页面处理</h3><p>![[_resources&#x2F;9773758d8ab278e59716fb0e84262593_MD5.png]]</p>
<h3 id="（二）监听器SpringApplicationRunListeners开启监听"><a href="#（二）监听器SpringApplicationRunListeners开启监听" class="headerlink" title="（二）监听器SpringApplicationRunListeners开启监听"></a>（二）监听器SpringApplicationRunListeners开启监听</h3><p>![[_resources&#x2F;4f39a3e363244975d7fc1361179dddf2_MD5.png]]</p>
<p>直接开始分析 <strong>ApringApplicationRunListeners</strong> ，内含SpringApplicationRunListener的集合，其中starting方法就是对listeners进行遍历，对每个listener都调用starting方法</p>
<p>![[_resources&#x2F;a6a334ad30bce394192fb5dc3e21a77f_MD5.png]]</p>
<p>SpringApplicationRunListener和ApplicationListener都是SpringBoot中的 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8&spm=1001.2101.3001.7020">事件监听器</a> ，但是它们所监听的事件和触发时机有所不同，其区别如下：</p>
<ol>
<li><strong>监听的事件不同</strong><br> SpringApplicationRunListener主要监听SpringApplication运行时的各种事件，例如应用程序开始启动、应用程序启动失败、应用程序启动完成等事件。而ApplicationListener主要监听Spring容器中的各种事件，例如Bean加载完成、上下文刷新完成等事件。</li>
<li><strong>触发时机不同</strong><br> SpringApplicationRunListener在SpringApplication启动时就开始工作，可以接收到应用程序开始启动、应用程序启动失败、应用程序启动成功等各种事件。而ApplicationListener则是在Spring容器启动完成后，才能开始工作，监听的是Spring容器中的各种事件。</li>
<li><strong>使用场景不同</strong><br> 在实际应用中，SpringApplicationRunListener主要用于监听SpringApplication的启动过程，例如在应用程序启动前后执行某些操作、监听应用程序启动失败事件并做出相应的操作等。而ApplicationListener则用于监听Spring容器中的各种事件，例如在Bean加载完成后做出相应的操作、在上下文刷新完成后更新一些状态等。</li>
</ol>
<p>总之，尽管SpringApplicationRunListener和ApplicationListener都是SpringBoot中的事件监听器，但是它们所监听的事件、触发时机、使用场景等都有所不同，我们需要根据具体的应用需求，选择合适的监听器来完成应用程序的事件处理。</p>
<p>在进入看一下SpringApplicationRunListener这个类</p>
<ol>
<li>package org.springframework.boot;</li>
<li>import org.springframework.context.ConfigurableApplicationContext;</li>
<li>import org.springframework.core.env.ConfigurableEnvironment;</li>
<li>public interface SpringApplicationRunListener {</li>
<li>void starting ();</li>
<li>void environmentPrepared (ConfigurableEnvironment environment);</li>
<li>void contextPrepared (ConfigurableApplicationContext context);</li>
<li>void contextLoaded (ConfigurableApplicationContext context);</li>
<li>void started (ConfigurableApplicationContext context);</li>
<li>void running (ConfigurableApplicationContext context);</li>
<li>void failed (ConfigurableApplicationContext context, Throwable exception);</li>
<li>}</li>
</ol>
<p>对应方法说明如下</p>
<table>
<thead>
<tr>
<th>监听方法</th>
<th>运行阶段说明</th>
<th>SpringBoot起始版本</th>
</tr>
</thead>
<tbody><tr>
<td><strong>contextLoaded(ConfigurationApplicationEnvironment)</strong></td>
<td><strong>ConfigurableApplicationContext完成加载</strong> ，但仍未启动；通知监听器，ApplicationContext已经完成IoC配置</td>
<td>1.0</td>
</tr>
<tr>
<td><strong>contextPrepared(ConfigurationApplicationEnvironment)</strong></td>
<td><strong>ConfigurableApplicationContext准备妥当</strong> ：通知监听器，ApplicationContext已经创建并初始化完成</td>
<td>1.0</td>
</tr>
<tr>
<td><strong>environmentPrepared(ConfigurationEnvironment)</strong></td>
<td><strong>ConfigurationEnvironment准备妥当</strong> ，允许将其调整</td>
<td>1.0</td>
</tr>
<tr>
<td><strong>failed(ConfigurationApplicationEnvironment,Throwable)</strong></td>
<td>Spring应用 <strong>运行失败</strong></td>
<td>2.0</td>
</tr>
<tr>
<td><strong>running(ConfigurationApplicationEnvironment)</strong></td>
<td>Spring应用 <strong>正在运行</strong></td>
<td>2.0</td>
</tr>
<tr>
<td><strong>started(ConfigurationApplicationEnvironment)</strong></td>
<td><strong>ConfigurableApplicationContext已启动</strong> ，此时SpringBean已初始化完成</td>
<td>2.0</td>
</tr>
<tr>
<td><strong>starting()</strong></td>
<td>run方法执行的时候立马执行:通知监听器， <strong>SpringBoot开始执行</strong></td>
<td>1.0</td>
</tr>
</tbody></table>
<p><strong>总的来说就是创建了应用的监听器SpringApplicationRunListeners并调用start()开始监听</strong> ，先在getRunListeners中获取了所有的监听器，然后starting开启</p>
<h3 id="（三）environmentPrepared环境准备处理"><a href="#（三）environmentPrepared环境准备处理" class="headerlink" title="（三）environmentPrepared环境准备处理"></a>（三）environmentPrepared环境准备处理</h3><p>![[_resources&#x2F;f9cfd27590eab17d1320b246a9034264_MD5.png]]</p>
<p>分析这段代码，进入准备环境的方法prepareEnvironment中，可以看到如下：</p>
<p>![[_resources&#x2F;91b4764b29cd56b5bc091b1aeeb51d55_MD5.png]]</p>
<p>首先创建了一个环境ConfigurationEnvironment(有的话就获取，没有则创建)</p>
<p>![[_resources&#x2F;9009d37855b071ee052a32c80dc0b033_MD5.png]]</p>
<p>回到该方法返回的地方，通过this.configureEnvironment对环境进行设置，接着如下：</p>
<p>![[_resources&#x2F;77d208aca2ef3512045f8604c0495dcc_MD5.png]]</p>
<p>环境配置好以后回调了SpringApplicationRunListener的environmentPrepared函数，进入该方法：</p>
<p>![[_resources&#x2F;c192ac999a5ad193164c1b6afbb97d90_MD5.png]]</p>
<p>可以看到environmentPrepared环境准备中进行了通知监听器，Environment准备完成。</p>
<p>回到开始处，可以看到环境准备完成后通过bindToSpringApplication将环境绑定到程序中。</p>
<h3 id="（四）banner打印"><a href="#（四）banner打印" class="headerlink" title="（四）banner打印"></a>（四）banner打印</h3><p>![[_resources&#x2F;87e01144b31b1ea8115a16b0d717a0e6_MD5.png]]</p>
<p>打印对应的banner信息</p>
<p>![[_resources&#x2F;36bd265621adebc8b61ce53235e91f65_MD5.png]]</p>
<p>也就是启动后的改部分，见如下</p>
<p>![[_resources&#x2F;7d7a7457955bc2deda32f85e27c25db8_MD5.png]]</p>
<p>实际中，改图可以进行替换，只需要在resources增加banner.txt信息即可，例如如下：</p>
<p>![[_resources&#x2F;255dcaf118f3092d51b4c77a23bf3826_MD5.png]]</p>
<p>其中的原理可以继续点开对应后续代码分析，这个后续中讲解替换思路。</p>
<h3 id="（五）创建Spring应用上下文"><a href="#（五）创建Spring应用上下文" class="headerlink" title="（五）创建Spring应用上下文"></a>（五）创建Spring应用上下文</h3><p>![[_resources&#x2F;dcfd7885e563e95548911060b6913cf9_MD5.png]]</p>
<p>创建应用上下文即IOC过程，IOC容器是驱动整体SpringBoot应用组件的核心，进入该方法：</p>
<p>![[_resources&#x2F;cd0afb9c9ad4e1d2aea90245d260aff2_MD5.png]]</p>
<p>这里的创建是根据SpringApplication在构造阶段所推断的web应用类型进行IOC容器的创建，IOC容器就是run返回的内容。</p>
<h3 id="（六）Spring应用上下文准备阶段"><a href="#（六）Spring应用上下文准备阶段" class="headerlink" title="（六）Spring应用上下文准备阶段"></a>（六）Spring应用上下文准备阶段</h3><p>![[_resources&#x2F;62dc5c835c66d198aeac52fff59f0f33_MD5.png]]</p>
<p>prepareContext方法将listeners、environment、applicationArguments、banner等重要组件与上下文对象关联,对上下文对象进行进一步配置，进入该方法具体分析：</p>
<p>![[_resources&#x2F;3794148f3b4c4868f38a71573f9d7727_MD5.png]]</p>
<p>可以看到首先分别保存了刚才生成的environment、ApplicationContext，接下来的applyInitializers方法是执行初始化，进入该方法</p>
<p>![[_resources&#x2F;35e440e2ab5a0ec75a2b893cd8e95366_MD5.png]]</p>
<p>方法内部遍历所有的initializer，然后依次回调里面所有的initialize方法（这些initializer就是在springboot刚启动时构造new springApplication时添加的），设置完当前环境并完成初始化之后，回调了所有Linsteners的contextPrepared方法</p>
<p>![[_resources&#x2F;91cbc5477244907e19d1d640238d1786_MD5.png]]</p>
<p>接下来将命令行参数和banner注册到IOC容器来，如下：</p>
<p>![[_resources&#x2F;4c02fb93e88d46bc5fa6cfc487a07340_MD5.png]]</p>
<p>最后全部操作都完成后，这个方法回调了Listeners的contextLoaded方法，如上。</p>
<h3 id="（七）Spring应用上下文刷新阶段"><a href="#（七）Spring应用上下文刷新阶段" class="headerlink" title="（七）Spring应用上下文刷新阶段"></a>（七）Spring应用上下文刷新阶段</h3><p>![[_resources&#x2F;0a811ff36b565d57b845693547ce175e_MD5.png]]</p>
<p>在该方法中首先注册了一个shutdownHook线程，用来实现SpringBean销毁生命周期回调</p>
<p>![[_resources&#x2F;74b94da47979bbfcb94b76ea06ee5bad_MD5.png]]</p>
<p>在执行完refresh之后的控制台，可以看到 tomcat 和一些IOC容器的bean都被加载进去了</p>
<p>![[_resources&#x2F;92963b151364bf42599da14e4e60d1c7_MD5.png]]</p>
<h3 id="（八）Spring应用上下文收尾阶段"><a href="#（八）Spring应用上下文收尾阶段" class="headerlink" title="（八）Spring应用上下文收尾阶段"></a>（八）Spring应用上下文收尾阶段</h3><p>![[_resources&#x2F;893ac98033310a46aab0edcd88cabb4c_MD5.png]]</p>
<p>其中afrerRefresh()并无内容处理，后续的版本中已经没有改方法了</p>
<ol>
<li>protected void afterRefresh (ConfigurableApplicationContext context,</li>
<li>ApplicationArguments args) {</li>
<li>}</li>
</ol>
<p>收尾计时器停止，同时调用监听器的started()。</p>
<h3 id="（九）回调工作处理"><a href="#（九）回调工作处理" class="headerlink" title="（九）回调工作处理"></a>（九）回调工作处理</h3><p>![[_resources&#x2F;bc2e8589d6510ced585e2d28b52c237f_MD5.png]]</p>
<p>进入该方法分析</p>
<p>![[_resources&#x2F;b843d9fd425052dadd105cf850aa5866_MD5.png]]</p>
<p>ApplicationContext就是IOC容器，这个方法从IOC容器中获取了所有的 <strong>ApplicationRunner和ConmmandLineRunner</strong> ，接下来进行遍历和回调。</p>
<p>在callRunners使用的这两个类几乎可以等价，都是用于做一些客户自定义的工作，而且是整个流程完成之后才会调用用户自己定义的实现类的run方法，这两个run方法的实现方法都是在容器基本初始化好的时候调用的。</p>
<p>紧接着，如果无异常代码执行如下：</p>
<p>![[_resources&#x2F;b817fdc8756dc90e423b7316bcccd0ce_MD5.png]]</p>
<p>监听器回调running()方法代表SpringApplication正常启动结束。</p>
<h3 id="（十）SpringApplication启动异常处理"><a href="#（十）SpringApplication启动异常处理" class="headerlink" title="（十）SpringApplication启动异常处理"></a>（十）SpringApplication启动异常处理</h3><p>![[_resources&#x2F;b0cc24ca8e39f58ed3cf7c8239ae2573_MD5.png]]</p>
<p>发生异常主要是对异常的处理，我们进入该方法分析</p>
<p>![[_resources&#x2F;388a19f4d01f89d5844c13c80fa1f4c2_MD5.png]]</p>
<p>可以看到这个异常报告类也是支持自定义并且自动配置的，配置结束后，Springboot做了一些基本的收尾工作，返回了应用环境上下文（IOC容器）。</p>
<h2 id="四、SpringBoot自动配置分析"><a href="#四、SpringBoot自动配置分析" class="headerlink" title="四、SpringBoot自动配置分析"></a>四、SpringBoot自动配置分析</h2><p>Spring Boot 的自动化配置模块是该框架的核心功能之一，它可以大大简化应用程序的配置工作。下面是对 Spring Boot 自动化配置模块的讲解和分析：</p>
<ol>
<li><strong>自动化配置的原理</strong> ：Spring Boot 的自动化配置模块 <strong>基于约定优于配置的原则</strong> 。它 <strong>通过在 classpath 下扫描依赖和配置，自动配置应用程序的各个组件。它使用条件化配置的机制，根据环境和条件自动选择适当的配置。</strong></li>
<li><strong>自动配置的实现方式</strong> ：Spring Boot 自动化配置模块使用了 <strong>@Conditional 注解和条件注解</strong> 来实现条件化配置。这些注解可以根据一组条件来决定是否启用某个配置。例如，@ConditionalOnClass 根据 classpath 中是否存在指定的类来判断是否启用配置。</li>
<li><strong>自动配置的加载顺序</strong> ： <strong>Spring Boot 的自动配置是通过在 classpath 下的 META-INF&#x2F;spring.factories 文件中定义的自动配置类来实现的。</strong> 这些自动配置类会被自动加载，并根据条件进行初始化和配置。 <strong>根据条件的不同，可以有多个自动配置类被加载，它们会按照优先级顺序进行配置</strong> 。</li>
<li><strong>自动配置的自定义</strong> ：Spring Boot 允许开发者对自动配置进行自定义。你可以使用 <strong>@Conditional 注解和条件注解</strong> 来定义自定义的条件，从而影响自动配置的行为。你还可以使用 <strong>@EnableAutoConfiguration 注解</strong> 来控制自动配置的启用或禁用。</li>
<li><strong>自动配置的好处</strong> ：Spring Boot 的自动化配置模块带来了很多好处。它大大减少了手动配置的工作量，提高了开发效率。它提供了合理的默认配置，减少了错误配置的风险。同时，它的条件化配置机制使得应用程序更具灵活性，能够根据不同的环境和需求进行动态的配置。</li>
</ol>
<p>总的来说，Spring Boot 的自动化配置模块是该框架的重要特性之一。它通过约定优于配置的原则和条件化配置机制，实现了自动加载和配置应用程序的各个组件。这为开发者提供了便利和灵活性，并大大简化了应用程序的配置过程。</p>
<p>现在回到我们一开始的图示分析，该配置模块的主要使用到了SpringFactoriesLoader，即 <strong>Spring工厂加载器</strong> ，该对象提供了loadFactoryNames方法，入参为factoryClass和classLoader，即需要 <strong>传入工厂类名称和对应的类加载器</strong> ，方法会根据指定的classLoader， <strong>加载该类加器搜索路径下的指定文件，即spring.factories文件</strong> ，传入的工厂类为接口， <strong>获取到这些实现类的类名后</strong> ，loadFactoryNames方法返回类名集合，方法调用方得到这些集合后， <strong>再通过反射获取这些类的类对象、构造方法，最终生成实例。</strong></p>
<h3 id="（一）自动装配原理分析"><a href="#（一）自动装配原理分析" class="headerlink" title="（一）自动装配原理分析"></a>（一）自动装配原理分析</h3><p>从@SpringBootApplication中的@EnableAutoConfiguration注解中可以看到其import了一个自动配置导入选择器AutoConfigurationImportSelect</p>
<ol>
<li>package org.springframework.boot.autoconfigure;</li>
<li>import java.lang.annotation.Documented;</li>
<li>import java.lang.annotation.ElementType;</li>
<li>import java.lang.annotation.Inherited;</li>
<li>import java.lang.annotation.Retention;</li>
<li>import java.lang.annotation.RetentionPolicy;</li>
<li>import java.lang.annotation.Target;</li>
<li>import org.springframework.context.annotation.Import;</li>
<li>@Target({ElementType.TYPE})</li>
<li>@Retention(RetentionPolicy.RUNTIME)</li>
<li>@Documented</li>
<li>@Inherited</li>
<li>@AutoConfigurationPackage</li>
<li>@Import({AutoConfigurationImportSelector.class})</li>
<li>public @interface EnableAutoConfiguration {</li>
<li>String ENABLED_OVERRIDE_PROPERTY = “spring.boot.enableautoconfiguration”;</li>
<li>Class&lt;?&gt;[] exclude() default {};</li>
<li>String[] excludeName() default {};</li>
<li>}</li>
</ol>
<p>其类图如下</p>
<p>![[_resources&#x2F;d94cb2e3fbfd7ac3614fe66c40e1f8fd_MD5.png]]</p>
<p>可以发现其最终实现了ImportSelector(选择器)和BeanClassLoaderAware(bean类加载器中间件)，其中这个选择器的作用就是导入组件。</p>
<p>所有自动装配的逻辑都是在AutoConfigurationImportSelector里面的selectImports方法中实现的</p>
<p>![[_resources&#x2F;bb330e0b28edc0697b148751f10b2c46_MD5.png]]</p>
<p>进入getAutoConfigurationEntry()方法</p>
<p>![[_resources&#x2F;3422b3794f83389451205dd45d707a49_MD5.png]]</p>
<p>进入getCandidateConfigurations()获取候选配置方法，可以看到核心的SpringFactoriesLoader的loadFactoryNames()方法</p>
<p>![[_resources&#x2F;8a739b6e91d797b3adda77d8a1941897_MD5.png]]</p>
<p>其中SpringFactoriesLoader是Spring Framework工厂机制的加载器，loadFactoryNames是其对应的加载方法，进入这个核心的loadFactoryNames方法中查看</p>
<p>![[_resources&#x2F;2d9309ebdaa00e2dc2215015d620b252_MD5.png]]</p>
<p>该处加载原理如下：</p>
<ul>
<li>扫描所有jar包路径下 META-INF&#x2F;spring.factories，这里是通过类加载器生成对应的url路径</li>
<li>把扫描到的内容包装成properties对象，并对这个对象的内容进行遍历，返回map，map的key为接口的全类名，value为接口全部实现类列表（列表里元素去重，防止重复加载），这个value的信息后续会作为loadSpringFactories方法的返回值</li>
<li>在上一步返回的map之中查找并返回指定类名映射的实现类全类名列表</li>
</ul>
<p>再看刚才getCandidateConfiguration方法中的getSpringFactoriesLoaderFactoryClass方法，返回的就是EnableAutoConfiguration类</p>
<p>![[_resources&#x2F;4a41a4a8bdff8b25c86be621e051958b_MD5.png]]</p>
<p>也就是说要从刚才properties中再获取这个类对应的值，把它们加到容器中。</p>
<p>选取mybatis- spring-boot -autoconfigure下的spring.factories文件分析一下：</p>
<p>![[_resources&#x2F;95b81aea3c32a96886adf64eddc7ed27_MD5.png]]</p>
<p>每一个 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中，用它们做自动配置；</p>
<p>只有进入到容器中，这些自动配置类才会起作用——进行自动配置功能</p>
<h3 id="（二）条件化自动装配"><a href="#（二）条件化自动装配" class="headerlink" title="（二）条件化自动装配"></a>（二）条件化自动装配</h3><p>对于使用@Configuration的自动配置类，其条件自动化装配以@condition为核心。在spring底层中的@conditional注解会根据不同的满足条件生效整个配置类里面的配置。</p>
<p>条件化装配可以分为以下几类：</p>
<p><strong>Class条件注解</strong></p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@ConditionalOnClass</td>
<td>指定类存在时生效</td>
</tr>
<tr>
<td>@ConditionalOnMissingClass</td>
<td>指定类缺失时生效</td>
</tr>
</tbody></table>
<p><strong>Bean条件注解</strong></p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@ConditionalOnBean</td>
<td>指定Bean存在时生效</td>
</tr>
<tr>
<td>@ConditionalOnMissingBean</td>
<td>指定Bean缺失时生效</td>
</tr>
</tbody></table>
<p><strong>属性条件注解</strong></p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@ConditionalOnProperty</td>
<td>使用属性(application.properties)的值判断是否生效</td>
</tr>
</tbody></table>
<p><strong>Web应用条件注解</strong></p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@ConditionalOnWebApplication</td>
<td>是web类型时生效</td>
</tr>
<tr>
<td>@ConditionalOnNotWebApplication</td>
<td>不是web类型时生效</td>
</tr>
</tbody></table>
<p><strong>其他条件注解</strong></p>
<table>
<thead>
<tr>
<th><strong>@Conditional扩展注解</strong></th>
<th><strong>作用（判断是否满足当前指定条件）</strong></th>
</tr>
</thead>
<tbody><tr>
<td>@ConditionalOnJava</td>
<td>系统的 java 版本是否符合要求</td>
</tr>
<tr>
<td>@ConditionalOnExpression</td>
<td>满足SpEL表达式指定</td>
</tr>
<tr>
<td>@ConditionalOnSingleCandidate</td>
<td>容器中只有一个指定的Bean，或者这个Bean是首选Bean</td>
</tr>
<tr>
<td>@ConditionalOnResource</td>
<td>类路径下是否存在指定资源文件</td>
</tr>
<tr>
<td>@ConditionalOnJndi</td>
<td>JNDI存在指定项</td>
</tr>
</tbody></table>
<p>分析@ConditionalOnWebApplication</p>
<ol>
<li>package org.springframework.boot.autoconfigure.condition;</li>
<li>import java.lang.annotation.Documented;</li>
<li>import java.lang.annotation.ElementType;</li>
<li>import java.lang.annotation.Retention;</li>
<li>import java.lang.annotation.RetentionPolicy;</li>
<li>import java.lang.annotation.Target;</li>
<li>import org.springframework.context.annotation.Conditional;</li>
<li>@Target({ElementType.TYPE, ElementType.METHOD})</li>
<li>@Retention(RetentionPolicy.RUNTIME)</li>
<li>@Documented</li>
<li>@Conditional({OnWebApplicationCondition.class})</li>
<li>public @interface ConditionalOnWebApplication {</li>
<li>ConditionalOnWebApplication.Type type () default ConditionalOnWebApplication.Type.ANY;</li>
<li>public static enum Type {</li>
<li>ANY,</li>
<li>SERVLET,</li>
<li>REACTIVE;</li>
<li>private Type () {</li>
<li>}</li>
<li>}</li>
<li>}</li>
</ol>
<p>进入OnWebApplicationCondition类，里面有一个getMatchOutcome()方法，就是判断是否符合当前配置条件</p>
<p>![[_resources&#x2F;fd6a1165e35d82f9154c4c73576c11c8_MD5.png]]</p>
<p>该方法首先判断是否使用了这个注释，然后使用isWebApplication来判断当前是否是web应用，这些match的方法判断指定的条件成立，才会给容器添加组件，配置内容才会生效。</p>
<h3 id="（三）自动配置原理举例：HttpEncodingAutoConfiguration（HTTP编码自动配置）"><a href="#（三）自动配置原理举例：HttpEncodingAutoConfiguration（HTTP编码自动配置）" class="headerlink" title="（三）自动配置原理举例：HttpEncodingAutoConfiguration（HTTP编码自动配置）"></a>（三）自动配置原理举例：HttpEncodingAutoConfiguration（HTTP编码自动配置）</h3><p>![[_resources&#x2F;1569ff963eae4c6f4763793e94a525e0_MD5.png]] 可以看到以下信息：</p>
<ul>
<li>@Configuration 代表这是一个配置类，类似编写的配置文件，也可以给容器中添加组件。</li>
<li>@EnableConfigurationProperties 启用指定类的ConfigurationProperties功能，将配置文件application.properties的值和ServerProperties绑定起来，并把ServerProperties加入到IOC容器中。</li>
<li>@ConditionalOnClass用来判断当前项目是否含有这个类，这里CharacterEncodingFilter的作用就是springMVC乱码解决的过滤器（以前在spring的xml文件中配置的），如果有这个过滤器则配置生效。</li>
<li>@ConditionalOnProperty判断这个配置是否存在，matchIfMissing &#x3D; true代表即使配置文件中不存在这个属性也是默认生效的。</li>
</ul>
<p>需要注意的是，在spring.factories中的自动配置类不是都能生效的，都有各自的生效条件。根据当前不同条件判断，来决定这个配置类是否生效；一旦配置类生效，这个配置类就会给容器添加各种组件，这些组件的属性从对应的properties中获取，这些类里面的每一个属性又是和配置文件绑定的。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>Spring Boot 的自动化配置和启动流程为开发者提供了简化的开发体验，降低了配置和启动的复杂性。通过深入理解 SpringApplication 的启动步骤、自动配置的原理以及 Spring Boot 如何无缝集成各类组件，我们不仅能更好地运用 Spring Boot，还能更灵活地定制和优化应用。自动配置是 Spring Boot 的核心之一，它通过精巧的条件判断实现了“按需配置”，确保应用在减少冗余的前提下获得所需的功能支持。</p>
<p>在实际开发中，理解这些原理可以帮助我们在遇到问题时更快找到原因，尤其是当我们需要进行调优或者定制配置时，更能从容应对。希望通过本文的分析，你能够更全面地掌握 Spring Boot 的核心机制，并在实际项目中充分发挥它的优势。</p>
<p>摘抄自网络，便于检索查找。</p>
<p>posted @ <a target="_blank" rel="noopener" href="https://www.cnblogs.com/Chary">CharyGao</a>   阅读(276)  评论(0) <a target="_blank" rel="noopener" href="https://www.cnblogs.com/Chary/p/">收藏</a> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/Chary/p/">举报</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/clippings/" class="print-no-link">#clippings</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Spring Boot 启动过程与自动配置详解：从源码到实现</div>
      <div>https://yhao521.github.io/2025/10/08/摘录/Spring Boot 启动过程与自动配置详解：从源码到实现/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>[[CharyGao]]</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月8日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/10/08/%E6%91%98%E5%BD%95/%E6%B7%B1%E5%85%A5SpringBoot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%9A%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E4%B8%8EBean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A0%B8%E5%BF%83%E8%A7%A3%E6%9E%90/" title="深入SpringBoot启动流程：自动配置与Bean生命周期核心解析">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">深入SpringBoot启动流程：自动配置与Bean生命周期核心解析</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/08/%E6%91%98%E5%BD%95/%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/" title="多租户看这一篇就够了">
                        <span class="hidden-mobile">多租户看这一篇就够了</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a>  
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
